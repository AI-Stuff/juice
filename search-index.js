var searchIndex = {};
searchIndex["juice"] = {"doc":"Juice is a open, modular and clear-designed Machine Intelligence Framework providing state-of-the-art performance for distributed (Deep|Machine) Learning - sharing concepts from Tensorflow and Caffe.","items":[[0,"layer","juice","Provides the generics and interfaces for the specific Layers.",null,null],[3,"Layer","juice::layer","The generic Layer",null,null],[12,"name","","Identifies the Network",0,null],[12,"config","","The configuration of the Layer",0,null],[12,"worker","","The [implementation][1] of the Layer. [1]: ../layers/index.html",0,null],[12,"weights_data","","The vector that stores shared references to the weights in the form of blobs.",0,null],[12,"weights_gradient","","The vector that stores shared references to the weights in the form of blobs.",0,null],[12,"input_blobs_data","","References to all the input blobs of the layer.",0,null],[12,"input_blobs_gradient","","References to all the input blobs of the layer.",0,null],[12,"input_blob_names","","Names for all the input blobs of the layer.",0,null],[12,"output_blobs_data","","References to all the output blobs of the layer.",0,null],[12,"output_blobs_gradient","","References to all the output blobs of the layer.",0,null],[12,"blob_names","","All the blobs of the layer that can be addressed by name.",0,null],[3,"LayerConfig","","Layer Configuration Struct",null,null],[12,"name","","The name of the Layer",1,null],[12,"layer_type","","The type of the Layer",1,null],[12,"outputs","","The name for each output Blob",1,null],[12,"inputs","","The name for each input Blob",1,null],[12,"params","","Specifies training configuration for each weight blob.",1,null],[12,"propagate_down","","Specifies on which inputs the backpropagation should be skipped. The size must be either 0 or equal to the number of inputs.",1,null],[4,"LayerType","","The Layer Types",null,null],[13,"Convolution","","Convolution Layer",2,null],[13,"Linear","","Linear Layer",2,null],[13,"LogSoftmax","","LogSoftmax Layer",2,null],[13,"Pooling","","Pooling Layer",2,null],[13,"Sequential","","Sequential Layer",2,null],[13,"Softmax","","Softmax Layer",2,null],[13,"ReLU","","ReLU Layer",2,null],[13,"TanH","","TanH Layer",2,null],[13,"Sigmoid","","Sigmoid Layer",2,null],[13,"NegativeLogLikelihood","","NegativeLogLikelihood Layer",2,null],[13,"Reshape","","Reshape Layer",2,null],[8,"ILayer","","A Layer in a Neural Network that can handle forward and backward of a computation step.",null,null],[11,"init","","Initialize the layer for computation.",3,{"inputs":[{"name":"self"},{"name":"rc"}],"output":null}],[11,"reshape","","Adjust to shapes of the output blobs to fit the shapes of the input blobs.",3,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":null}],[11,"resize_shared_workspace","","Adjust size of shared workspace.",3,{"inputs":[{"name":"self"},{"name":"rc"},{"generics":["arclock"],"name":"option"}],"output":{"generics":["arclock"],"name":"option"}}],[11,"forward","","Compute the [feedforward][1] layer output using the provided Backend. [1]: https://en.wikipedia.org/wiki/Feedforward_neural_network",3,null],[11,"backward_input","","Compute the [backpropagation][1] input gradient using the provided backend. [1]: https://en.wikipedia.org/wiki/Backpropagation",3,null],[11,"backward_parameters","","Compute the [backpropagation][1] parameters gradient using the provided backend. [1]: https://en.wikipedia.org/wiki/Backpropagation",3,null],[11,"auto_output_blobs","","Return whether \"anonymous\" output blobs are created automatically for the layer.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"min_output_blobs","","Returns the minimum number of output blobs required by the layer, or 0 if no minimum number is required.",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"exact_num_output_blobs","","Returns the exact number of output blobs required by the layer, or `None` if no exact number is required.",3,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"auto_weight_blobs","","Return whether weight blobs are created automatically for the layer.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"exact_num_input_blobs","","Returns the exact number of input blobs required by the layer, or `None` if no exact number is required.",3,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"allow_force_backward","","Return whether to allow force_backward for a given input blob index.",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"sync_native","","Return wether a simple native backend should be used to [sync][1] instead of the default backend. [1]: #method.sync",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"compute_in_place","","Return wether the computations of a layer should be done in-place (the output will be written where the input was read from).",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_container","","Return wether the layer is a container.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"loss_weight","","Return the associated loss weight for a given output blob index.",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["f32"],"name":"option"}}],[11,"inputs_data","","Return the input tensors of the layer.",3,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"inputs_gradients","","Return the gradients of the input tensors of the layer.",3,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"outputs_data","","Return the output tensors of the layer.",3,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"outputs_gradients","","Return the gradients of the output tensors of the layer.",3,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"learnable_weights","","Return the learnable weights inside the layer.",3,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"learnable_weights_gradients","","Return the gradients for the learnable weights inside the layer.",3,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"learnable_weights_names","","Return the names of the learnable weights inside the layer.",3,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"learnable_weights_lr","","Return the learning rates for the learnable weights inside the layer.",3,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[8,"ComputeOutput","","A Layer that can compute the output for a given input.",null,null],[10,"compute_output","","Compute output for given input and write them into `output_data`.",4,null],[8,"ComputeInputGradient","","A Layer that can compute the gradient with respect to its input.",null,null],[10,"compute_input_gradient","","Compute gradients with respect to the inputs and write them into `input_gradients`.",5,null],[8,"ComputeParametersGradient","","A Layer that can compute the gradient with respect to its parameters (= weights, bias, etc.).",null,null],[11,"compute_parameters_gradient","","Compute gradients with respect to the parameters and write them into `parameters_gradients`.",6,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"connect","","Connect the layer to another layers and set up tensors for intermediate results and weights.",0,{"inputs":[{"name":"self"},{"name":"hashmap"},{"name":"hashmap"}],"output":null}],[11,"init_backprop","","Initializes layer for [backpropagation][1] [1]: https://en.wikipedia.org/wiki/Backpropagation",0,{"inputs":[{"name":"self"},{"name":"hashset"},{"name":"hashset"}],"output":null}],[11,"init_force_backward","","Set [backpropagation][1] flags to force this layer to backpropagate. [1]: https://en.wikipedia.org/wiki/Backpropagation",0,{"inputs":[{"name":"self"}],"output":null}],[11,"forward","","Uses the underlying layer implementation to compute a forward step.",0,null],[11,"backward","","Uses the underlying layer implementation to compute a backward step.",0,null],[11,"backward_input","","Calculate the gradient w.r.t. input.",0,null],[11,"backward_parameters","","Calculate the gradient w.r.t. parameters.",0,{"inputs":[{"name":"self"}],"output":null}],[11,"synchronize","","Synchronize the layers backend.",0,{"inputs":[{"name":"self"}],"output":null}],[11,"update_weights","","Updates the [weights][1] with the weight update computed by the [Solver][2]. [1]: https://en.wikipedia.org/wiki/Synaptic_weight [2]: ../solver/struct.Solver.html",0,{"inputs":[{"name":"self"},{"name":"solverb"}],"output":null}],[11,"clear_weights_gradients","","Clears the [weights][1] gradients and zero-inits them. [1]: https://en.wikipedia.org/wiki/Synaptic_weight",0,{"inputs":[{"name":"self"}],"output":null}],[11,"save","","Serialize the Layer and it's weights to a Cap'n Proto file at the specified path.",0,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"result"}}],[11,"load","","Read a Cap'n Proto file at the specified path and deserialize the Layer inside it.",0,{"inputs":[{"name":"rc"},{"name":"p"}],"output":{"generics":["layer"],"name":"result"}}],[11,"set_weight_propagate_down","","Sets whether the layer should compute gradients w.r.t. a weight at a particular index given by `weight_id`.",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"bool"}],"output":null}],[11,"is_using_in_place","","Returns `true` when the layer is using in-place computation.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"input_blob_names","","Returns the names of all the input blobs.",0,null],[11,"loss","","Returns the [loss weight][1] associated with the weight blob with id `weight_id`. [1]: http://caffe.berkeleyvision.org/tutorial/loss.html",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["f32"],"name":"option"}}],[11,"learnable_weights_data","","Returns all the learnable weights in the layer.",0,{"inputs":[{"name":"self"}],"output":{"generics":["arclock"],"name":"vec"}}],[11,"learnable_weights_gradients","","Returns the gradients for all the learnable weights in the layer.",0,{"inputs":[{"name":"self"}],"output":{"generics":["arclock"],"name":"vec"}}],[11,"learnable_weights_names","","Returns the names of all the learnable weights in the layer.",0,{"inputs":[{"name":"self"}],"output":{"generics":["string"],"name":"vec"}}],[11,"learnable_weights_lr","","Returns the learning rate for all the learnable weights in the layer.",0,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"vec"}}],[11,"from_config","","Creates a new Layer from a [LayerConfig][1]. [1]: ./struct.LayerConfig.html",0,{"inputs":[{"name":"rc"},{"name":"layerconfig"}],"output":{"name":"layer"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"layerconfig"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"layertype"}}],[11,"supports_in_place","","Returns wether the LayerType supports in-place operations.",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"new","","Creates a new LayerConfig",1,{"inputs":[{"name":"str"},{"name":"l"}],"output":{"name":"layerconfig"}}],[11,"output","","Returns the Name of the requested output Blob",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["string"],"name":"option"}}],[11,"outputs_len","","Returns the number of output Blobs",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"add_output","","Add a output by name",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":null}],[11,"input","","Returns the Name of the requested input Blob",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["string"],"name":"option"}}],[11,"inputs_len","","Returns the number of input Blobs",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"add_input","","Add a input by name",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":null}],[11,"param","","Returns the requested WeightConfig",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["weightconfig"],"name":"option"}}],[11,"params_len","","Returns the number of params",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"validate","","Check if the configured parameters make sense.",1,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"result"}}],[0,"layers","juice","Provides the fundamental units of computation in a Neural Network.",null,null],[0,"activation","juice::layers","Provides nonlinear activation methods.",null,null],[0,"relu","juice::layers::activation","Applies the nonlinear Rectified Linear Unit.",null,null],[3,"ReLU","juice::layers::activation::relu","ReLU Activation Layer",null,null],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"relu"}}],[11,"exact_num_output_blobs","","",7,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"exact_num_input_blobs","","",7,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"compute_in_place","","",7,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"reshape","","",7,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":null}],[11,"compute_output","","",7,null],[11,"compute_input_gradient","","",7,null],[0,"sigmoid","juice::layers::activation","Applies the nonlinear Log-Sigmoid function.",null,null],[3,"Sigmoid","juice::layers::activation::sigmoid","Sigmoid Activation Layer",null,null],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"sigmoid"}}],[11,"exact_num_output_blobs","","",8,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"exact_num_input_blobs","","",8,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"compute_in_place","","",8,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"reshape","","",8,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":null}],[11,"compute_output","","",8,null],[11,"compute_input_gradient","","",8,null],[0,"tanh","juice::layers::activation","Applies the nonlinear TanH function.",null,null],[3,"TanH","juice::layers::activation::tanh","TanH Activation Layer",null,null],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"tanh"}}],[11,"exact_num_output_blobs","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"exact_num_input_blobs","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"compute_in_place","","",9,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"reshape","","",9,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":null}],[11,"compute_output","","",9,null],[11,"compute_input_gradient","","",9,null],[0,"common","juice::layers","Provides common neural network layers.",null,null],[0,"convolution","juice::layers::common","Convolves the input tensor.",null,null],[3,"Convolution","juice::layers::common::convolution","Convolution Layer",null,null],[3,"ConvolutionConfig","","Specifies configuration parameters for a Convolution Layer.",null,null],[12,"num_output","","The number of output feature maps",10,null],[12,"filter_shape","","The size of the kernel",10,null],[12,"stride","","The stride size",10,null],[12,"padding","","The padding size",10,null],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"convolution"}}],[11,"from_config","","Create a Convolution layer from a ConvolutionConfig.",11,{"inputs":[{"name":"convolutionconfig"}],"output":{"name":"convolution"}}],[11,"num_spatial_dims","","Calculates the number of spatial dimensions for the convolution operation.",11,null],[11,"calculate_output_shape","","",11,null],[11,"filter_shape","","",11,null],[11,"stride","","",11,null],[11,"padding","","",11,null],[11,"exact_num_output_blobs","","",11,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"exact_num_input_blobs","","",11,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"auto_weight_blobs","","",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"reshape","","",11,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":null}],[11,"resize_shared_workspace","","",11,{"inputs":[{"name":"self"},{"name":"rc"},{"generics":["arclock"],"name":"option"}],"output":{"generics":["arclock"],"name":"option"}}],[11,"compute_output","","",11,null],[11,"compute_input_gradient","","",11,null],[11,"compute_parameters_gradient","","",11,null],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"convolutionconfig"}}],[11,"into","","",10,{"inputs":[{"name":"self"}],"output":{"name":"layertype"}}],[0,"linear","juice::layers::common","Applies a linear transformation to the input data `y = a * x + b`",null,null],[3,"Linear","juice::layers::common::linear","Linear Layer",null,null],[3,"LinearConfig","","Specifies configuration parameters for a Linear Layer.",null,null],[12,"output_size","","The number of output values",12,null],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_config","","Create a Linear layer from a LinearConfig.",13,{"inputs":[{"name":"linearconfig"}],"output":{"name":"linear"}}],[11,"exact_num_output_blobs","","",13,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"exact_num_input_blobs","","",13,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"auto_weight_blobs","","",13,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"reshape","","",13,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":null}],[11,"compute_output","","",13,null],[11,"compute_input_gradient","","",13,null],[11,"compute_parameters_gradient","","",13,null],[11,"default","","",13,{"inputs":[],"output":{"name":"linear"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"linearconfig"}}],[11,"into","","",12,{"inputs":[{"name":"self"}],"output":{"name":"layertype"}}],[0,"log_softmax","juice::layers::common","Computes the logarithmic softmax of its input.",null,null],[3,"LogSoftmax","juice::layers::common::log_softmax","LogSoftmax Layer",null,null],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"logsoftmax"}}],[11,"reshape","","",14,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":null}],[11,"compute_output","","",14,null],[11,"compute_input_gradient","","",14,null],[11,"default","","",14,{"inputs":[],"output":{"name":"logsoftmax"}}],[0,"pooling","juice::layers::common","Applies pooling to the input.",null,null],[3,"Pooling","juice::layers::common::pooling","Pooling Layer",null,null],[3,"PoolingConfig","","Specifies configuration parameters for a Pooling Layer.",null,null],[12,"mode","","The PoolingMode to use",15,null],[12,"filter_shape","","The shape of the filter",15,null],[12,"stride","","The stride size",15,null],[12,"padding","","The padding size",15,null],[4,"PoolingMode","","The different modes of pooling that can be calculated.",null,null],[13,"Max","","The maximum value inside the pooling window will be used as result.",16,null],[13,"Average","","The average of all values inside the pooling window will be used as result.",16,null],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"pooling"}}],[11,"from_config","","Create a Pooling layer from a PoolingConfig.",17,{"inputs":[{"name":"poolingconfig"}],"output":{"name":"pooling"}}],[11,"num_spatial_dims","","Calculates the number of spatial dimensions for the pooling operation.",17,null],[11,"calculate_output_shape","","",17,null],[11,"filter_shape","","",17,null],[11,"stride","","",17,null],[11,"padding","","",17,null],[11,"exact_num_output_blobs","","",17,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"exact_num_input_blobs","","",17,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"reshape","","",17,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":null}],[11,"compute_output","","",17,null],[11,"compute_input_gradient","","",17,null],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"poolingconfig"}}],[11,"into","","",15,{"inputs":[{"name":"self"}],"output":{"name":"layertype"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"poolingmode"}}],[0,"softmax","juice::layers::common","Computes the softmax of its input.",null,null],[3,"Softmax","juice::layers::common::softmax","Softmax Layer",null,null],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"softmax"}}],[11,"reshape","","",18,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":null}],[11,"compute_output","","",18,null],[11,"compute_input_gradient","","",18,null],[11,"default","","",18,{"inputs":[],"output":{"name":"softmax"}}],[8,"FilterLayer","juice::layers::common","Provides common utilities for Layers that utilize a filter with stride and padding.",null,null],[11,"calculate_spatial_output_dims","","Computes the shape of the spatial dimensions.",19,null],[10,"calculate_output_shape","","Calculate output shape based on the shape of filter, padding, stride and input.",19,null],[10,"num_spatial_dims","","Calculates the number of spatial dimensions for the pooling operation.",19,null],[11,"spatial_filter_dims","","Retrievs the spatial dimensions for the filter based on `self.filter_shape()` and the number of spatial dimensions.",19,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["usize"],"name":"vec"}}],[11,"stride_dims","","Retrievs the stride for the convolution based on `self.stride` and the number of spatial dimensions.",19,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["usize"],"name":"vec"}}],[11,"padding_dims","","Retrievs the padding for the convolution based on `self.padding` and the number of spatial dimensions.",19,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["usize"],"name":"vec"}}],[10,"filter_shape","","The filter_shape that will be used by `spatial_filter_dims`.",19,null],[10,"stride","","The stride that will be used by `stride_dims`.",19,null],[10,"padding","","The padding that will be used by `padding_dims`.",19,null],[0,"loss","juice::layers","Provides methods to calculate the loss (cost) of some output.",null,null],[0,"negative_log_likelihood","juice::layers::loss","TODO: DOC",null,null],[3,"NegativeLogLikelihood","juice::layers::loss::negative_log_likelihood","NegativeLogLikelihood Loss Layer",null,null],[3,"NegativeLogLikelihoodConfig","","Specifies configuration parameters for a NegativeLogLikelihood Layer.",null,null],[12,"num_classes","","How many different classes can be classified.",20,null],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"negativeloglikelihood"}}],[11,"from_config","","Create a NegativeLogLikelihood layer from a NegativeLogLikelihoodConfig.",21,{"inputs":[{"name":"negativeloglikelihoodconfig"}],"output":{"name":"negativeloglikelihood"}}],[11,"exact_num_output_blobs","","",21,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"exact_num_input_blobs","","",21,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"auto_output_blobs","","",21,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"loss_weight","","",21,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["f32"],"name":"option"}}],[11,"sync_native","","",21,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"reshape","","",21,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":null}],[11,"compute_output","","",21,null],[11,"compute_input_gradient","","",21,null],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"negativeloglikelihoodconfig"}}],[11,"into","","",20,{"inputs":[{"name":"self"}],"output":{"name":"layertype"}}],[0,"utility","juice::layers","Provides various helpful layers, which might be not directly related to neural networks in general.",null,null],[0,"flatten","juice::layers::utility","Flattens the bottom Blob into a simpler top Blob.",null,null],[3,"Flatten","juice::layers::utility::flatten","Flattening Utility Layer",null,null],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"flatten"}}],[0,"reshape","juice::layers::utility","Utility layer to give a tensor another shape.",null,null],[3,"Reshape","juice::layers::utility::reshape","Reshape Utility Layer",null,null],[3,"ReshapeConfig","","Specifies configuration parameters for a Reshape Layer.",null,null],[12,"shape","","The target shape that the input should assume.",23,null],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"reshape"}}],[11,"from_config","","Create a Reshape layer from a ReshapeConfig.",24,{"inputs":[{"name":"reshapeconfig"}],"output":{"name":"reshape"}}],[11,"compute_in_place","","",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"auto_output_blobs","","",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"reshape","","",24,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":null}],[11,"compute_output","","",24,null],[11,"compute_input_gradient","","",24,null],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"reshapeconfig"}}],[11,"of_shape","","Create a ReshapeConfig that describes a Reshape layer with a provided shape.",23,null],[11,"into","","",23,{"inputs":[{"name":"self"}],"output":{"name":"layertype"}}],[0,"container","juice::layers","Provides container layers.",null,null],[0,"sequential","juice::layers::container","A container layer that runs operations sequentially on the contained layers.",null,null],[3,"Sequential","juice::layers::container::sequential","Sequential Layer",null,null],[3,"SequentialConfig","","Specifies configuration parameters for a Sequential Layer.",null,null],[12,"layers","","Defines the layers of the container via [LayerConfig][layer_config]s.",25,null],[12,"inputs","","Defines the names and shapes of the input tensors.",25,null],[12,"force_backward","","Defines if the container will force every layer to do [backpropagation][1]. [1]: https://en.wikipedia.org/wiki/Backpropagation",25,null],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Create a empty Sequential container layer.",26,{"inputs":[],"output":{"name":"sequential"}}],[11,"from_config","","Create a Sequential layer from a SequentialConfig.",26,{"inputs":[{"name":"rc"},{"name":"sequentialconfig"}],"output":{"name":"sequential"}}],[11,"init_layers","","Initializes a sequential container.",26,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"sequentialconfig"}],"output":null}],[11,"is_container","","",26,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"inputs_data","","",26,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"inputs_gradients","","",26,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"outputs_data","","",26,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"outputs_gradients","","",26,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"learnable_weights","","",26,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"learnable_weights_gradients","","",26,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"learnable_weights_names","","",26,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[11,"resize_shared_workspace","","",26,{"inputs":[{"name":"self"},{"name":"rc"},{"generics":["arclock"],"name":"option"}],"output":{"generics":["arclock"],"name":"option"}}],[11,"forward","","",26,null],[11,"backward_input","","",26,null],[11,"backward_parameters","","",26,null],[11,"compute_output","","",26,null],[11,"compute_input_gradient","","",26,null],[11,"compute_parameters_gradient","","",26,null],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",25,{"inputs":[{"name":"self"}],"output":{"name":"sequentialconfig"}}],[11,"find_in_place_output","","Tries to find the output of a previous layer that is usable as in-place output for the n-th layer.",25,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["string"],"name":"option"}}],[11,"add_layer","","Add layer at the end of the sequential container.",25,{"inputs":[{"name":"self"},{"name":"layerconfig"}],"output":null}],[11,"add_input","","Add a input to the network.",25,null],[11,"into","","",25,{"inputs":[{"name":"self"}],"output":{"name":"layertype"}}],[11,"default","","",25,{"inputs":[],"output":{"name":"sequentialconfig"}}],[0,"solver","juice","Provides the generics and interfaces for the specific Solvers.",null,null],[3,"Solver","juice::solver","Solver that optimizes a [Layer][1] with a given objective. [1]: ../layer/index.html",null,null],[12,"worker","","The implementation of the Solver",27,null],[3,"SolverConfig","","Configuration for a Solver",null,null],[12,"name","","Name of the solver.",28,null],[12,"network","","The [LayerConfig][1] that is used to initialize the network. [1]: ../layer/struct.LayerConfig.html",28,null],[12,"objective","","The [LayerConfig][1] that is used to initialize the objective. [1]: ../layer/struct.LayerConfig.html",28,null],[12,"solver","","The [Solver implementation][1] to be used. [1]: ../solvers/index.html",28,null],[12,"minibatch_size","","Accumulate gradients over `minibatch_size` instances.",28,null],[12,"lr_policy","","The learning rate policy to be used.",28,null],[12,"base_lr","","The base learning rate.",28,null],[12,"gamma","","gamma as used in the calculation of most learning rate policies.",28,null],[12,"stepsize","","The stepsize used in Step and Sigmoid learning policies.",28,null],[12,"clip_gradients","","The threshold for clipping gradients.",28,null],[12,"weight_decay","","The global [weight decay][1] multiplier for [regularization][2]. [1]: http://www.alglib.net/dataanalysis/improvinggeneralization.php#header3 [2]: https://cs231n.github.io/neural-networks-2/#reg",28,null],[12,"regularization_method","","The method of [regularization][1] to use. [1]: https://cs231n.github.io/neural-networks-2/#reg",28,null],[12,"momentum","","The [momentum][1] multiplier for [SGD solvers][2]. [1]: https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Momentum [2]: ../solvers/sgd/index.html",28,null],[4,"SolverKind","","All available types of solvers.",null,null],[13,"SGD","","Stochastic Gradient Descent. See [SGDKind][1] for all available SGD solvers. [1]: ./enum.SGDKind.html",29,null],[4,"SGDKind","","All available types of Stochastic Gradient Descent solvers.",null,null],[13,"Momentum","","Stochastic Gradient Descent with Momentum. See [implementation][1] [1] ../solvers/",30,null],[4,"LRPolicy","","Learning Rate Policy for a [Solver][1] [1]: ./struct.Solver.html",null,null],[13,"Fixed","","always return base_lr",31,null],[13,"Step","","learning rate decays every `step` iterations. return base_lr * gamma ^ (floor(iter / step))",31,null],[13,"Exp","","return base_lr * gamma ^ iter",31,null],[4,"RegularizationMethod","","[Regularization][1] method for a [Solver][2]. [1]: https://cs231n.github.io/neural-networks-2/#reg [2]: ./struct.Solver.html",null,null],[13,"L2","","L2 regularization",32,null],[0,"confusion_matrix","","TODO: DOC",null,null],[3,"ConfusionMatrix","juice::solver::confusion_matrix","A [ConfusionMatrix][wiki].",null,null],[3,"Sample","","A single prediction Sample.",null,null],[3,"Accuracy","","The accuracy of the predictions in a ConfusionMatrix.",null,null],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a ConfusionMatrix that analyzes the prediction of `num_classes` classes.",33,{"inputs":[{"name":"usize"}],"output":{"name":"confusionmatrix"}}],[11,"add_sample","","Add a sample by providing the expected `target` class and the `prediction`.",33,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"add_samples","","Add a batch of samples.",33,null],[11,"get_predictions","","Get the predicted classes from the output of a network.",33,{"inputs":[{"name":"self"},{"name":"sharedtensor"}],"output":{"generics":["usize"],"name":"vec"}}],[11,"set_capacity","","Set the `capacity` of the ConfusionMatrix",33,{"inputs":[{"name":"self"},{"generics":["usize"],"name":"option"}],"output":null}],[11,"samples","","Return all collected samples.",33,{"inputs":[{"name":"self"}],"output":{"name":"vecdeque"}}],[11,"accuracy","","Return the accuracy of the collected predictions.",33,{"inputs":[{"name":"self"}],"output":{"name":"accuracy"}}],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",34,{"inputs":[{"name":"self"}],"output":{"name":"sample"}}],[11,"correct","","Returns if the prediction is equal to the expected target.",34,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",35,{"inputs":[{"name":"self"}],"output":{"name":"accuracy"}}],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[8,"ISolver","juice::solver","Implementation of a specific Solver.",null,null],[11,"init","","Initialize the solver, setting up any network related data.",36,{"inputs":[{"name":"self"},{"name":"layer"}],"output":null}],[10,"compute_update","","Update the weights of the net with part of the gradient.",36,{"inputs":[{"name":"self"},{"name":"solverconfig"},{"name":"layer"},{"name":"usize"}],"output":null}],[10,"backend","","Returns the backend used by the solver.",36,{"inputs":[{"name":"self"}],"output":{"name":"solverb"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_config","","Create Solver from [SolverConfig][1] [1]: ./struct.SolverConfig.html",27,{"inputs":[{"name":"rc"},{"name":"rc"},{"name":"solverconfig"}],"output":{"name":"solver"}}],[11,"train_minibatch","","Train the network with one minibatch",27,{"inputs":[{"name":"self"},{"generics":["sharedtensor"],"name":"arclock"},{"generics":["sharedtensor"],"name":"arclock"}],"output":{"generics":["sharedtensor"],"name":"arclock"}}],[11,"network","","Returns the network trained by the solver.",27,{"inputs":[{"name":"self"}],"output":{"name":"layer"}}],[11,"mut_network","","Returns the network trained by the solver.",27,{"inputs":[{"name":"self"}],"output":{"name":"layer"}}],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"solverconfig"}}],[11,"default","","",28,{"inputs":[],"output":{"name":"solverconfig"}}],[11,"get_learning_rate","","Return the learning rate for a supplied iteration.",28,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"solverkind"}}],[11,"with_config","","Create a Solver of the specified kind with the supplied SolverConfig.",29,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"solverconfig"}],"output":{"generics":["isolver"],"name":"box"}}],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",30,{"inputs":[{"name":"self"}],"output":{"name":"sgdkind"}}],[11,"with_config","","Create a Solver of the specified kind with the supplied SolverConfig.",30,{"inputs":[{"name":"self"},{"name":"rc"},{"name":"solverconfig"}],"output":{"generics":["isolver"],"name":"box"}}],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"lrpolicy"}}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",32,{"inputs":[{"name":"self"}],"output":{"name":"regularizationmethod"}}],[0,"solvers","juice","Provides the trainers for the Layers.",null,null],[0,"sgd","juice::solvers","Provides ISolver implementations based on [Stochastic Gradient Descent][2]. [2]: https://en.wikipedia.org/wiki/Stochastic_gradient_descent",null,null],[0,"momentum","juice::solvers::sgd","A [Stochastic Gradient Descent with Momentum][1] [1]: https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Momentum",null,null],[3,"Momentum","juice::solvers::sgd::momentum","Stochastic Gradient Descent with Momentum.",null,null],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new SGD Momentum solver.",37,{"inputs":[{"name":"rc"}],"output":{"name":"momentum"}}],[11,"init","","Initialize the SGD Momentum solver, allocating memory for its history.",37,{"inputs":[{"name":"self"},{"name":"layer"}],"output":null}],[11,"compute_update","","",37,{"inputs":[{"name":"self"},{"name":"solverconfig"},{"name":"layer"},{"name":"usize"}],"output":null}],[11,"backend","","",37,{"inputs":[{"name":"self"}],"output":{"name":"solverb"}}],[0,"weight","juice","Provides configuration of weights and their initialization.",null,null],[3,"WeightConfig","juice::weight","Specifies training configuration for a weight blob.",null,null],[12,"name","","The name of the weight blob -- useful for sharing weights among layers, but never required otherwise. To share a weight between two layers, give it a (non-empty) name.",38,null],[12,"share_mode","","Whether to require shared weights to have the same shape, or just the same count",38,null],[12,"lr_mult","","The multiplier on the global learning rate for this parameter.",38,null],[12,"decay_mult","","The multiplier on the global weight decay for this parameter.",38,null],[12,"filler","","The filler that initializes the weights in the weight blob.",38,null],[4,"DimCheckMode","","Enum for specifing the shared weights behaviour",null,null],[13,"Strict","","Strict requires that shapes match.",39,null],[13,"Permissive","","Permissive requires only the count of weights to match.",39,null],[4,"FillerType","","Enum for specifing the type of Filler.",null,null],[13,"Constant","","Fills the weight blob with a constant `value` (all values are the same).",40,null],[12,"value","juice::weight::FillerType","The value that will be used to fill the blob.",40,null],[13,"Glorot","juice::weight","Fills the weight blobs based on the paper:",40,null],[12,"input_size","juice::weight::FillerType","Number of input nodes for each output.",40,null],[12,"output_size","","Number of output nodes for each input.",40,null],[11,"fmt","juice::weight","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",38,{"inputs":[{"name":"self"}],"output":{"name":"weightconfig"}}],[11,"default","","",38,{"inputs":[],"output":{"name":"weightconfig"}}],[11,"check_dimensions","","Checks dimensions of two blobs according to the `share_mode`. Returns an error if there is a count/shape mismatch.",38,{"inputs":[{"name":"self"},{"name":"sharedtensor"},{"name":"sharedtensor"},{"name":"string"},{"name":"string"},{"name":"string"}],"output":{"generics":["string"],"name":"result"}}],[11,"lr_mult","","The multiplier on the global learning rate for this weight blob.",38,{"inputs":[{"name":"self"}],"output":{"name":"f32"}}],[11,"decay_mult","","The multiplier on the global weight decay for this weight blob.",38,{"inputs":[{"name":"self"}],"output":{"name":"f32"}}],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",39,{"inputs":[{"name":"self"}],"output":{"name":"dimcheckmode"}}],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",40,{"inputs":[{"name":"self"}],"output":{"name":"fillertype"}}],[11,"fill","","Uses a filler as specified by this FillerType to fill the values in a SharedTensor",40,{"inputs":[{"name":"self"},{"name":"sharedtensor"}],"output":null}],[11,"fill_constant","","Directly use the Constant Filler.",40,{"inputs":[{"name":"sharedtensor"},{"name":"f32"}],"output":null}],[11,"fill_glorot","","Directly use the Glorot Filler.",40,{"inputs":[{"name":"sharedtensor"},{"name":"usize"},{"name":"usize"}],"output":null}],[0,"util","juice","Provides common utility functions",null,null],[5,"native_backend","juice::util","Create a simple native backend.",null,{"inputs":[],"output":{"generics":["native"],"name":"backend"}}],[5,"write_to_memory","","Write into a native Coaster Memory.",null,null],[5,"write_to_memory_offset","","Write into a native Coaster Memory with a offset.",null,null],[5,"write_batch_sample","","Write the `i`th sample of a batch into a SharedTensor.",null,null],[5,"native_scalar","","Create a Coaster SharedTensor for a scalar value.",null,{"inputs":[{"name":"t"}],"output":{"name":"sharedtensor"}}],[5,"cast_vec_usize_to_i32","","Casts a Vec to as Vec",null,{"inputs":[{"generics":["usize"],"name":"vec"}],"output":{"generics":["i32"],"name":"vec"}}],[6,"ArcLock","","Shared Lock used for our tensors",null,null],[8,"Axpby","","Extends IBlas with Axpby",null,null],[11,"axpby","","Performs the operation y := ax + by .",41,{"inputs":[{"name":"self"},{"name":"sharedtensor"},{"name":"sharedtensor"},{"name":"sharedtensor"},{"name":"sharedtensor"}],"output":{"generics":["error"],"name":"result"}}],[8,"SolverOps","","Encapsulates all traits required by Solvers.",null,null],[8,"LayerOps","","Encapsulates all traits used in Layers.",null,null],[14,"impl_ilayer_activation","juice","",null,null],[14,"impl_ilayer_common","","",null,null],[14,"impl_ilayer_loss","","",null,null],[14,"impl_isolver_sgd","","Implement [ISolver][1] for [SGD solvers][2]. [1]: ./solver/trait.ISolver.html [2]: ./solvers/sgd/index.html",null,null]],"paths":[[3,"Layer"],[3,"LayerConfig"],[4,"LayerType"],[8,"ILayer"],[8,"ComputeOutput"],[8,"ComputeInputGradient"],[8,"ComputeParametersGradient"],[3,"ReLU"],[3,"Sigmoid"],[3,"TanH"],[3,"ConvolutionConfig"],[3,"Convolution"],[3,"LinearConfig"],[3,"Linear"],[3,"LogSoftmax"],[3,"PoolingConfig"],[4,"PoolingMode"],[3,"Pooling"],[3,"Softmax"],[8,"FilterLayer"],[3,"NegativeLogLikelihoodConfig"],[3,"NegativeLogLikelihood"],[3,"Flatten"],[3,"ReshapeConfig"],[3,"Reshape"],[3,"SequentialConfig"],[3,"Sequential"],[3,"Solver"],[3,"SolverConfig"],[4,"SolverKind"],[4,"SGDKind"],[4,"LRPolicy"],[4,"RegularizationMethod"],[3,"ConfusionMatrix"],[3,"Sample"],[3,"Accuracy"],[8,"ISolver"],[3,"Momentum"],[3,"WeightConfig"],[4,"DimCheckMode"],[4,"FillerType"],[8,"Axpby"]]};
initSearch(searchIndex);
